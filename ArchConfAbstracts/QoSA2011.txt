	
3. Integration of event-based communication in the Palladio software quality prediction framework
Klatt, Benjamin (1); Rathfelder, Christoph (1); Kounev, Samuel (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 43-52, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000268; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) FZI Research Center for Information Technology, Karlsruhe, Germany (2) Karlsruhe Institute of Technology, Karlsruhe, Germany
Abstract: Today, software engineering is challenged to handle more and more large-scale distributed systems with guaranteed quality-of-service. Component-based architectures have been established to build such systems in a more structured and manageable way. Modern architectures often utilize event-based communication which enables loosely-coupled interactions between components and leads to improved system scalability. However, the loose coupling of components makes it challenging to model such architectures in order to predict their quality properties, e.g., performance and reliability, at system design time. In this paper, we present an extension of the Palladio Component Model (PCM) and the Palladio software quality prediction framework, enabling the modeling of event-based communication in component-based architectures. The contributions include: i) a meta-model extension supporting events as first class entities, ii) a mode-to-model transformation from the extended to the original PCM, iii) an integration of the transformation into the Palladio tool chain allowing to use existing model solution techniques, and iv) a detailed evaluation of the reduction of the modeling effort enabled by the transformation in the context of a real-world case study. © 2011 ACM. (31 refs)
Main heading: Software architecture
Controlled terms: Communication - Computer software selection and evaluation - Forecasting - Quality of service - Systems analysis
Uncontrolled terms: Component model - Component-based architecture - Event-based - Large-scale distributed system - Loose couplings - Meta model - Model solution - Modern architectures - performance prediction - Quality properties - Software quality prediction - System scalability
Classification Code: 716 Telecommunication; Radar, Radio and Television - 723 Computer Software, Data Handling and Applications - 921 Mathematics - 961 Systems Science
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
4. Reliability prediction for fault-tolerant software architectures
Brosch, Franz (1); Buhnova, Barbora (2); Koziolek, Heiko (3); Reussner, Ralf (4)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 75-84, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000274; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Research Center for Information Technology (FZI), Karlsruhe, Germany (2) Masaryk University, Brno, Czech Republic (3) Industrial Software Systems, ABB Corporate Research, Ladenburg, Germany (4) Karlsruhe Institute of Technology (KIT), Karlsruhe, Germany
Abstract: Software fault tolerance mechanisms aim at improving the reliability of software systems. Their effectiveness (i.e., reliability impact) is highly application-specific and depends on the overall system architecture and usage profile. When examining multiple architecture configurations, such as in software product lines, it is a complex and error-prone task to include fault tolerance mechanisms effectively. Existing approaches for reliability analysis of software architectures either do not support modelling fault tolerance mechanisms or are not designed for an efficient evaluation of multiple architecture variants. We present a novel approach to analyse the effect of software fault tolerance mechanisms in varying architecture configurations. We have validated the approach in multiple case studies, including a large-scale industrial system, demonstrating its ability to support architecture design, and its robustness against imprecise input data. © 2011 ACM. (27 refs)
Main heading: Software architecture
Controlled terms: Fault tolerance - Reliability analysis - Software reliability
Uncontrolled terms: Architecture configuration - Architecture designs - Component-based software architecture - Error prones - Fault tolerance mechanisms - Fault-tolerant software - Industrial systems - Input datas - Multiple-case study - Reliability impacts - reliability prediction - Software fault tolerances - Software Product Line - software product lines - Software systems - System architectures
Classification Code: 722.4 Digital Computers and Systems - 723.1 Computer Programming - 913 Production Planning and Control; Manufacturing - 913.3 Quality Assurance and Control
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
5. Software architecture adaptability metrics for QoS-based self-adaptation
Perez-Palacin, Diego (1); Mirandola, Raffaela (2); Merseguer, José (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 171-175, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000288; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Dpto. de Informática e Ingeniería de Sistemas, Universidad de Zaragoza, Zaragoza, Spain (2) Politecnico di Milano, Dipartimento di Elettronica e Informazione, Milano, Italy
Abstract: One of the major current research trends in Software Engineering is the focus on the development of new techniques to deal efficiently with the design of systems that are able to evolve overtime and adapt to rapid changes of their requirements. However, it is still an open issue how to quantify and evaluate the adaptability of a given software system. In this paper we propose the definition of metrics able to quantify and evaluate such software adaptability at the architectural level. Besides, we define a relationship with the quality of service that the software must guarantee by means of a relation between the values of these metrics and the system quality requirements. The presented metrics can be used by the software architect to guide the system adaptation to fulfill the overall quality requirements. © 2011 ACM. (14 refs)
Main heading: Software architecture
Controlled terms: Quality control - Quality of service
Uncontrolled terms: adaptability metrics - Architectural levels - Overall quality - Rapid changes - Research trends - Self adaptation - Software adaptability - Software architects - Software systems - System adaptation - System quality
Classification Code: 716 Telecommunication; Radar, Radio and Television - 717 Optical Communication - 718 Telephone Systems and Related Technologies; Line Communications - 723 Computer Software, Data Handling and Applications - 913.3 Quality Assurance and Control
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
6. Enhancing a QoS-based self-adaptive framework with energy management capabilities
Perez-Palacin, Diego (1); Mirandola, Raffaela (2); Merseguer, José (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 165-169, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000287; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Dpto. de Informática e Ingeniería de Sistemas, Universidad de Zaragoza, Zaragoza, Spain (2) Dip. di Elettronica e Informazione, Politecnico di Milano, Milano, Italy
Abstract: The energy use is becoming a key design consideration in computing infrastructures and services. In this paper we focus on service-based applications and we propose an adaptation process that can be used to reduce power consumption. This adaptation process is materialized in an adaptation plan which fits into a software architecture specifically designed for self-adaptive systems. The adaptation plan guarantees a trade-off between energy consumption and QoS offered, while maintaining suitable revenues for the service provider. The proposed approach is based on the principle of proportional energy consumption obtained by scaling down energy for unused resources, considering both the number of servers switched on and the operating frequencies of that servers. © 2011 ACM. (13 refs)
Main heading: Software architecture
Controlled terms: Adaptive systems - Energy utilization - Petri nets
Uncontrolled terms: Adaptation process - Computing infrastructures - Design considerations - energy - Energy use - Operating frequency - performance - Scaling down - Self-adaptive - Self-adaptive system - Service provider - Service-based - Stochastic Petri Nets
Classification Code: 525.3 Energy Utilization - 723.1 Computer Programming - 731.1 Control Systems - 921.4 Combinatorial Mathematics, Includes Graph Theory, Set Theory
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
7. Empirically-grounded reference architectures: A proposal
Galster, Matthias (1); Avgeriou, Paris (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 153-157, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000285; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) University of Groningen, Netherlands
Abstract: A reference architecture describes core elements of the software architecture for systems that stem from the same domain. A reference architecture ensures interoperability of systems through standardization. It also facilitates the instantiation of new concrete architectures. However, we currently lack procedures for systematically designing reference architectures that are empirically-grounded. Being empirically-grounded would increase the validity and reusability of a reference architecture. We therefore present an approach which helps systematically design reference architectures. Our approach consists of six steps performed by the software architect and domain experts. It helps design reference architectures either from scratch, or based on existing architecture artifacts. We also illustrate how our approach could be applied to the design of two existing reference architectures found in literature. © 2011 ACM. (18 refs)
Main heading: Software architecture
Controlled terms: Design - Interoperability - Reusability
Uncontrolled terms: Concrete architecture - Core elements - Design process - Domain experts - empirically-grounded - reference architecture - Software architects
Classification Code: 408 Structural Design - 452.3 Industrial Wastes - 716 Telecommunication; Radar, Radio and Television - 717 Optical Communication - 718 Telephone Systems and Related Technologies; Line Communications - 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
8. A metric-based safety workflow for electric/electronic architectures of vehicles
Hillenbrand, Martin (1); Heinz, Matthias (1); Müller-Glaser, Klaus D. (1); Adler, Nico (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 105-114, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000278; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Institute for Information Processing Technologies (ITIV), Karlsruhe Institute of Technology (KIT), Vincenz-Prienitz-Strae 1, Karlsruhe, Germany (2) FZI Forschungszentrum Informatik, Haid-und-Neu-Strae 10-14, Karlsruhe, Germany
Abstract: The ISO 26262 -Functional Safety for Road Vehicles- describes a safety life-cycle, that has to be considered concurrently to the life-cycle of the vehicle development. Also the design of the electric/electronic architecture does not specify the implementation of electronic and software based vehicle functions, it forms the basis for their realization and distribution to the vehicle’s networked hardware artifacts. In this paper we present the formal and tool-based approach for the propagation of ISO 26262 safety goals to artifacts of an initial electric/electronic architecture. With a set of metrics, we evaluate the architecture before and after its safety refinement, respective to the high level failure modes omission and commission. The process of annotation, evaluation and refinement is exemplary shown at the electric/electronic architecture for a retractable rear spoiler. © 2011 ACM. (12 refs)
Main heading: Software architecture
Controlled terms: Failure modes - Life cycle - Safety engineering - Vehicles
Uncontrolled terms: e/e-architecture - functional safety - iso 26262 - Rear spoiler - Road vehicles - Safety goals - Software-based - Vehicle development - Vehicle functions
Classification Code: 421 Strength of Building Materials; Mechanical Properties - 432 Highway Transportation - 723.1 Computer Programming - 913.1 Production Engineering - 914 Safety Engineering - 921 Mathematics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
9. Towards a process for architectural modelling in agile software development
Durdik, Zoya (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 183-192, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000291; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Software Engineering (SE), IT-Research Center FZI, 76131 Karlsruhe, Germany
Abstract: Agile methods and architectural modelling have been considered to be mutually exclusive. On the one hand, agile methods try to reduce overheads by avoiding activities that do not directly contribute to the immediate needs of the current project. This often leads to bad cross-project reuse. On the other hand, architectural modelling is considered a pre requisite for the systematic cross-project reuse and for the resulting increase in software developer productivity. The theme of this paper is to address the relationship between agile methods and architectural modelling and to propose a novel process for agile architectural modelling, which drives requirements elicitation through the use of patterns and components. This process is in-line with agile principles and is illustrated on an example application. Additionally, the paper points out the challenges connected to the process validation and proposes an approach for the empirical validation addressing these challenges. © 2011 ACM. (66 refs)
Main heading: Software design
Controlled terms: Computer software reusability - Software architecture
Uncontrolled terms: Agile methods - architectural modelling - component selection - design patterns - Development process - scrum
Classification Code: 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
10. Systematic simplicity-accuracy tradeoffs in parameterised contract models
Peake, Ian D. (1); Schmidt, Heinz W. (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 95-104, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000276; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) School of Computer Science and Information Technology, RMIT University, Melbourne, VIC, Australia
Abstract: Contract models underlying architecture-level verification methods must suit a range of different accuracy vs analytical complexity tradeoffs depending on domain. For example, trustworthiness in safety-critical systems is enabled by representational simplicity leading to comprehensible proofs while real-time systems require precise characterisation of execution time. A family of mutually-compatible parameterised contract models enabling such tradeoffs is needed, supporting reasoning about consistency and conformance (replaceability) which is bidirectional (from requirements to provisions and vice versa) and parametric (context-sensitive). This paper proposes a framework for such a family. The framework extends a previous formalisation of parameterised contracts. It provides more general notions of conformance, bidirectional reasoning and parameterisation, suitable for compositional architectural analyses of software products and product lines, for which software architects do not only need checking but scope for restricting or enriching service and interface contracts in predictable and compositional ways. The family of mechanisms presented here covers a range of levels of expressiveness, spanning the established four levels of component contracts, and is worked out in detail with examples for two common existing representations - tables and finite automata. © 2011 ACM. (25 refs)
Main heading: Software architecture
Controlled terms: Models - Parameterization - Real time systems
Uncontrolled terms: Architectural analysis - architectural dependence - Characterisation - Component contracts - Context-sensitive - design by contract - Execution time - Formalisation - parameterised contracts - Product-lines - Safety critical systems - Software architects - software components - Software products - Verification method
Classification Code: 722.4 Digital Computers and Systems - 723.1 Computer Programming - 902.1 Engineering Graphics - 921 Mathematics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
11. Elective temporal logic
Costa, Gabriele (1); Matteucci, Ilaria (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 143-152, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000283; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) University of Pisa, IIT-CNR, Pisa, Italy (2) IIT-CNR, Pisa, Italy
Abstract: In this paper we present a novel formalism for defining properties over linear execution traces, namely elective temporal logic (ETL). Differently from several other temporal logics, ETL is not dedicated to a specific time model, e.g. discrete time or real time. Hence, properties can be applied to each temporal context with no changes to the specified formulas. Moreover, the ETL denotational semantics is given through elective functions. In this way we map formulas into the characteristic functions of a set of accepted traces, i.e. the valid executions. A further contribution of this work is an application of ETL to runtime monitoring. As a matter of fact, using a security monitor driven by an ETL formula, we can ignore irrelevant security actions performed by the guarded program reducing the monitor workload. © 2011 ACM. (15 refs)
Main heading: Temporal logic
Controlled terms: Semantics - Software architecture
Uncontrolled terms: Characteristic functions - Denotational semantics - Discrete time - elective temporal logic - Execution trace - history-based verification - program monitoring - Real time - Runtime Monitoring - Specific time
Classification Code: 721.1 Computer Theory, Includes Formal Logic, Automata Theory, Switching Theory, Programming Theory - 723.1 Computer Programming - 903.2 Information Dissemination
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
12. Architecture-based fault tolerance support for grid applications
Yusuf, Iman I. (1); Schmidt, Heinz W. (1); Peake, Ian D. (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 177-181, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000289; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) School of Computer Science and IT, RMIT University, Melbourne, VIC, Australia
Abstract: Failure in long running grid applications is arguably inevitable and costly. Therefore, fault tolerance (FT) support for grid applications is needed. This paper evaluates an extension of our prior work on Recovery Aware Components (RAC), a component based FT approach. Our extension utilizes the grid application architecture according to a small number of architectural classes. In this paper, we evaluate the MapReduce architecture only and analyze the reliability improvement MapReduce applications would gain by adopting the RAC approach. Our analysis shows that significant increases in reliability are possible at moderate extra cost. Obviously the cost of FT depends on the failure rate of the managed system, i.e., the system to be protected from faults, and the FT strategy chosen. Our work aims to give High Performance Computing (HPC) software architects the tools to control these factors for dierent grid application architectures. © 2011 ACM. (25 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Cost benefit analysis - Fault tolerance - Reliability analysis
Uncontrolled terms: Component based - Failure rate - grid - Grid applications - High-performance computing - Map-reduce - Reliability improvement - Software architects
Classification Code: 722.4 Digital Computers and Systems - 723 Computer Software, Data Handling and Applications - 911 Cost and Value Engineering; Industrial Economics - 913 Production Planning and Control; Manufacturing
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
13. Sustainability evaluation of software architectures: A systematic review
Koziolek, Heiko (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 3-12, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000263; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Industrial Software Systems, ABB Corporate Research, Ladenburg, Germany
Abstract: Long-living software systems are sustainable if they can be cost-efficiently maintained and evolved over their entire life-cycle. The quality of software architectures determines sustainability to a large extent. Scenario-based software architecture evaluation methods can support sustainability analysis, but they are still reluctantly used in practice. They are also not integrated with architecture-level metrics when evaluating implemented systems, which limits their capabilities. Existing literature reviews for architecture evaluation focus on scenario-based methods, but do not provide a critical reflection of the applicability of such methods for sustainability evaluation. Our goal is to measure the sustainability of a software architecture both during early design using scenarios and during evolution using scenarios and metrics, which is highly relevant in practice. We thus provide a systematic literature review assessing scenario-based methods for sustainability support and categorize more than 40 architecture-level metrics according to several design principles. Our review identifies a need for further empirical research, for the integration of existing methods, and for the more efficient use of formal architectural models. © 2011 ACM. (70 refs)
Main heading: Software architecture
Controlled terms: Sustainable development
Uncontrolled terms: architectural metric - Architectural models - Architecture evaluation - Critical reflections - Design Principles - Empirical research - evolution scenario - Literature reviews - Scenario-based methods - Software architecture evaluation - Software systems - Sustainability analysis - Systematic literature review - Systematic Review
Classification Code: 723.1 Computer Programming - 911.2 Industrial Economics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
14. Extending the RiPLE-DE process with quality attribute variability realization
Cavalcanti, Ricardo De Oliveira (1); De Almeida, Eduardo Santana (2); Meira, Silvio R.L. (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 159-163, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000286; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Federal University of Pernambuco, P.O. Box 7851, 50732-970 Recife - PE, Brazil (2) Federal University of Bahia and RiSE, Campus de Ondina, Av. Adhemar de Barros, S/N, 40170-110 Salvador - BA, Brazil
Abstract: Software product lines engineering is a viable way to achieve the productivity gains desired by companies. Product line architecture must benefit from commonalities among products in the family and enable the variability among them. The aspect of variability in quality attributes has been neglected or ignored by most of the researchers as attention has been mainly put in functional variability. This paper describes an architecture and design process for software product lines that can properly deal with quality attribute variability. The proposed approach enhances the RiPLE-DE process for software product line engineering with activities and guidelines for quality attribute variability. An initial experimental study is presented to characterize and evaluate the proposed process enhancements. © 2011 ACM. (14 refs)
Main heading: Software architecture
Controlled terms: Computer software reusability - Network architecture - Production engineering - Productivity - Software design
Uncontrolled terms: Design process - Experimental studies - Product line architecture - Productivity gain - Quality attributes - Software Product Line - Software product line engineerings - software product lines (spl) - Software Re-use
Classification Code: 723 Computer Software, Data Handling and Applications - 913.1 Production Engineering
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
15. Performance measurements and modeling of a java-based Session Initiation Protocol (SIP) application server
Franks, Greg (1); Lau, Danny (1); Hrischuk, Curtis (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 63-72, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000270; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Department of Systems and Computer Engineering, Carleton University, Ottawa, ON K1S 5B6, Canada (2) GTS Architecture and Technical Solution Design, IBM, Durham, NC 27703, United States
Abstract: The Session Initiation Protocol (SIP) is an Internet protocol for establishing sessions between two or more parties. It is becoming ubiquitous in uses such as Voice over IP, instant messaging, Internet TV, and others. Performance is a chief concern with SIP because Quality of Service is important and SIP has internal timers that need to be honored or network efficiency suffers. The Java community has even provided a standardized API so that SIP applications can now be built using Java application servers. These new capabilities also bring with them new performance engineering methods, tools, and benchmarking needs. This paper describes the experiences and processes for the performance engineering of SIP applications in a Java environment. In this paper, a Java 2 Enterprise Edition (J2EE) SIP application server’s performance is analyzed in a standalone and cluster environment, with network traces used to build a performance model of each environment. This included gathering data from test runs and extracting performance parameters from packet traces to construct the performance models. The models are then calibrated to match the model prediction with real system test data. Using the calibrated models, some bottlenecks were identified and suggestions to improve the overall maximum throughput were developed and were subsequently implemented in the system. © 2011 ACM. (16 refs)
Main heading: Internet protocols
Controlled terms: Application programming interfaces (API) - Computer software - Ethers - Internet - Internet telephony - Java programming language - Network architecture - Network layers - Quality of service - Software architecture - Telecommunication networks - Voice/data communication systems
Uncontrolled terms: Application Servers - Calibrated model - Cluster environments - Instant messaging - Java 2 Enterprise Edition - Java application servers - Layered queueing networks - Maximum through-put - Model prediction - OR-networks - performance analysis - Performance engineering - Performance measurements - Performance Model - Performance parameters - Real systems - Session initiation protocol - Session Initiation Protocols - SIP application - Test runs - two-phase server - Voice over IP
Classification Code: 716 Telecommunication; Radar, Radio and Television - 717 Optical Communication - 718 Telephone Systems and Related Technologies; Line Communications - 718.1 Telephone Systems and Equipment - 723 Computer Software, Data Handling and Applications - 804.1 Organic Compounds
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
16. Managing the quality of software product line architectures through reusable model transformations
Kavimandan, Amogh (1); Gokhale, Aniruddha (1); Karsai, Gabor (1); Gray, Jeff (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 13-22, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000264; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Dept. of EECS, Vanderbilt University, Nashville, TN 37235, United States (2) Dept. of CS, University of Alabama, Tuscaloosa, AL 35487, United States
Abstract: In model-driven engineering of applications, the quality of the software architecture is realized and preserved in the successive stages of its lifecycle through model transformations. However, limited support for reuse in contemporary model transformation techniques forces developers of product line architectures to reinvent transformation rules for every variant of the product line, which can adversely impact developer productivity and in turn degrade the quality of the resulting software architecture for the variant. To overcome these challenges, this paper presents the MTS (Model-transformation Templatization and Specialization generative transformation process, which promotes reuse in model transformations through parameterization and specialization of transformation rules. MTS defines two higher order transformations to capture the variability in transformation rules and to specialize them across product variants. The core idea behind MTS is realized within a graphical model transformation tool in a way that is minimally intrusive to the underlying tool’s implementation. The paper uses two product line case studies to evaluate MTS in terms of reduction in efforts to define model transformation rules as new variants are added to the product line, and the overhead in executing the higher order transformations. These metrics provide an indirect measure of how potential degradation in the quality of software architectures of product lines caused due to lack of reuse can be alleviated by MTS. © 2011 ACM. (24 refs)
Main heading: Software architecture
Controlled terms: Computer software reusability - Computer software selection and evaluation - Software design
Uncontrolled terms: Contemporary models - GraphicaL model - Higher order - Indirect measure - Model transformation - Model-driven Engineering - Product line architecture - Product variants - Product-lines - Quality of softwares - reuse - software quality - Transformation process - Transformation rules - Two-product
Classification Code: 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
17. PerOpteryx: Automated application of tactics in multi-objective software architecture optimization
Koziolek, Anne (1); Koziolek, Heiko (2); Reussner, Ralf (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 33-42, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000267; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Karlsruhe Institute of Technology, Karlsruhe, Germany (2) ABB Corporate Research, Ladenburg, Germany
Abstract: Designing software architectures that exhibit a good trade-off between multiple quality attributes is hard. Even with a given functional design, many degrees of freedom in the software architecture (e.g. component deployment or server configuration) span a large design space. In current practice, software architects try to find good solutions manually, which is time-consuming, can be error-prone and can lead to suboptimal designs. We propose an automated approach guided by architectural tactics to search the design space for good solutions. Our approach applies multi-objective evolutionary optimization to software architectures modelled with the Palladio Component Model. Software architects can then make well-informed trade-off decisions and choose the best architecture for their situation. To validate our approach, we applied it to the architecture models of two systems, a business reporting system and an industrial control system from ABB. The approach was able to find meaningful trade-offs leading to significant performance improvements or costs savings. The novel use of tactics decreased the time needed to find good solutions by up to 80%. © 2011 ACM. (31 refs)
Main heading: Software architecture
Controlled terms: Commerce - Design - Economic and social effects - Multiobjective optimization - Software reliability
Uncontrolled terms: architectural tactics - Architecture models - Architecture optimization - Automated applications - Automated approach - Component deployment - Component model - Design spaces - Error prones - Evolutionary optimizations - Functional design - Industrial control systems - Large designs - Multi objective - Multiple quality - performance - Performance improvements - Reporting systems - Software architects - Sub-optimal designs
Classification Code: 408 Structural Design - 723.1 Computer Programming - 911.2 Industrial Economics - 913.3 Quality Assurance and Control - 921.5 Optimization Techniques - 971 Social Sciences
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
18. Building components with embedded security monitors
Khan, Muhammad Umair Ahmed (1); Zulkernine, Mohammad (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 133-142, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000282; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) School of Computing, Queen’s University, Kingston, ON, Canada
Abstract: A software component should be trustworthy and behave in a secure manner as it will be reused many times. Despite extensive efforts, usually, it cannot be guaranteed that a developed software component is completely secure. Hence, its execution in the real-world needs to be monitored against its security specifications. Each time components are used to develop a component-based software (CBS), a new monitor has to be designed to observe the behavior of the CBS. This results in recurring costs as such monitors cannot be reused for other CBS. Moreover, development life cycle artifacts are usually not available when a pre-fabricated component is used to build a CBS. Given that, it is imperative that a specification-based security monitor is developed along with the monitored component (when all development artifacts are available) and is embedded in the component to increase the component’s trustworthiness. In this paper, we identify the types of constraints that may be imposed by security specifications. These constraints should be taken into account while developing the software components and should also be monitored. Furthermore, we propose a design approach to develop components with built in monitors that are able to observe these security constraints. Components developed following this approach would be self-monitoring, promote greater reusability, and be more trustworthy. We evaluate our approach by analyzing the performance and design complexity of different versions of CBS. These versions are developed by following the traditional and proposed approaches for monitoring security aspects of CBS. © 2011 ACM. (35 refs)
Main heading: Network security
Controlled terms: Electric circuit breakers - Embedded software - Reusability - Software architecture - Specifications
Uncontrolled terms: Component based software - Design approaches - Design complexity - Embedded security - Recurring costs - Security constraint - Security monitoring - self-monitoring - Software component - Time components
Classification Code: 452.3 Industrial Wastes - 706.2 Electric Power Lines and Equipment - 723 Computer Software, Data Handling and Applications - 902.2 Codes and Standards
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
19. Modeling security attacks with statecharts
El Ariss, Omar (1); Xu, Dianxiang (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 123-132, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000281; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Department of Computer Science, North Dakota State University, Fargo, ND, United States (2) National Center for the Protection of the Financial Infrastructure, Dakota State University, Madison, SD, United States
Abstract: Software security is becoming a key quality concern as software applications are increasingly being used in untrustworthy computing environments such as the internet. Software is designed with the mindset of its functionalities and cost, where the focus is on the operational behavior while security concerns are neglected or marginally considered. As a result, software engineers build the software while lacking the knowledge about security and its effect on the system. This paper presents an approach for modeling the behavior of security threats using statecharts. The proposed approach introduces modular design for representing threats through the use of components and reusability. Through the focus on the behavior of an attack, software engineers can clearly define and understand security concerns as the application is being designed and developed. In addition, modeling security threats with statecharts makes it convenient to build a consistent semantic link between functional behaviors and security concerns. © 2011 ACM. (27 refs)
Main heading: Security of data
Controlled terms: Engineers - Reusability - Security systems - Semantics - Software architecture - Software design
Uncontrolled terms: Attack tree - Computing environments - Functional behaviors - Modular designs - Operational behavior - Security attacks - Security threats - Semantic link - Software applications - Software engineers - software security - Statecharts - Threat modeling
Classification Code: 452.3 Industrial Wastes - 723 Computer Software, Data Handling and Applications - 903.2 Information Dissemination - 912.4 Personnel - 914.1 Accidents and Accident Prevention
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
20. Combining clustering and pattern detection for the reengineering of component-based software systems
Von Detten, Markus (1); Becker, Steffen (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 23-32, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000265; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Heinz Nixdorf Institute, Department of Computer Science, University of Paderborn, Paderborn, Germany
Abstract: During the software lifecycle, software systems have to be continuously maintained to counteract architectural deterioration and retain their software quality. In order to maintain a software it has to be understood first which can be supported by (semi-)automatic reverse engineering approaches. Reverse engineering is the analysis of software for the purpose of recovering its design documentation, e.g., in form of the conceptual architecture. Today, the most prevalent reverse engineering approaches are (1) the clustering based approach which groups the elements of a given software system based on metric values in order to provide an overview of the system and (2) the pattern-based approach which tries to detect pre-defined patterns in the software which can give insight about the original developers’ intentions. In this paper, we present an approach towards combining these techniques: we show how the detection and removal of certain bad smells in a software system can improve the results of a clustering-based analysis. We propose to integrate this combination of reverse engineering approaches into a reengineering process for component-based software systems. © 2011 ACM. (35 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Engineering - Reengineering - Reverse engineering
Uncontrolled terms: bad smell detection - clustering - Component-based software systems - Conceptual architecture - Design documentation - Metric values - metrics - Pattern detection - Software life cycles - Software Quality - Software systems
Classification Code: 723 Computer Software, Data Handling and Applications - 901 Engineering Profession - 913.3 Quality Assurance and Control
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
21. Failure-dependent execution time analysis
Höfig, Kai (1); Domis, Dominik (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 115-121, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000279; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) University of Kaiserslautern, AG Software Engineering: Dependability, 67653 Kaiserslautern, Germany
Abstract: The growing complexity of safety-critical embedded systems is leading to an increased complexity of safety analysis models. Often used fault tolerance mechanisms have complex failure behavior and produce overhead compared to systems without such mechanisms. The question arises whether the overhead for fault tolerance is acceptable for the increased safety of a system. Manually modeling the timing behavior is cost intensive and error prone. Current approaches of safety analysis and execution time analysis are not able to reflect the timing behavior of complex mechanisms according to failures. In this paper, we describe an approach that combines safety analysis models with execution times to extract different execution times for different failure conditions. This provides a detailed view on the safety behavior in combination with the produced overhead and allows to find and certify appropriate fault tolerance mechanisms. © 2011 ACM. (28 refs)
Main heading: Fault tolerance
Controlled terms: Embedded systems - Models - Safety engineering - Security systems - Software architecture
Uncontrolled terms: Complex failure - Complex mechanisms - Error prones - Execution time - Failure conditions - Fault tolerance mechanisms - Fault-trees - Hard real-time - Increased safety - IS costs - Safety analysis - Safety behavior - Safety critical software - Safety-critical embedded systems - Worst-case execution time
Classification Code: 722 Computer Systems and Equipment - 722.4 Digital Computers and Systems - 723 Computer Software, Data Handling and Applications - 902.1 Engineering Graphics - 914 Safety Engineering - 914.1 Accidents and Accident Prevention
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
22. Architecture-based reliability evaluation under uncertainty
Meedeniya, Indika (1); Moser, Irene (1); Aleti, Aldeida (1); Grunske, Lars (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 85-94, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000275; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) Faculty of Information and Communication Technologies, Swinburne University of Technology, Hawthorn, VIC 3122, Australia (2) Faculty of Computer Science, Center for Mathematical and Computational Modelling (CM), University of Kaiserslautern, D-67653, Kaiserslautern, Germany
Abstract: The accuracy of architecture-based reliability evaluations depends on a number of parameters that need to be estimated, such as environmental factors or system usage. Researchers have tackled this problem by including uncertainties in architecture evaluation models and solving them analytically and with simulations. The usual assumption is that the input parameter distributions are normal, and that it is sufficient to report the attributes that describe the system in terms of the mean and variance of the attribute. In this work, we introduce a simulation-based approach that can accommodate a diverse set of parameter range distributions, self-regulate the number of architecture evaluations to the desired significance level and reports the desired percentiles of the values which ultimately characterise a specific quality attribute of the system. We include a case study which illustrates the flexibility of this approach using the evaluation of system reliability. © 2011 ACM. (38 refs)
Main heading: Software architecture
Controlled terms: Computer simulation - Monte Carlo methods - Parameter estimation - Reliability - Uncertainty analysis
Uncontrolled terms: Architecture evaluation - Environmental factors - Input parameter - Monte Carlo Simulation - Parameter range - Quality attributes - Reliability Evaluation - Simulation-based - software architecture evaluation - System reliability
Classification Code: 723.5 Computer Applications - 731.1 Control Systems - 922.1 Probability Theory - 922.2 Mathematical Statistics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
23. Ginpex: Deriving performance-relevant infrastructure properties through goal-oriented experiments
Hauck, Michael (1); Kuperberg, Michael (2); Huber, Nikolaus (2); Reussner, Ralf (2)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 53-62, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000269; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) FZI Research Center for Information Technology, Karlsruhe, Germany (2) Karlsruhe Institute of Technology, Karlsruhe, Germany
Abstract: In software performance engineering, the infrastructure on which an application is running plays a crucial role when predicting the performance of the application. Thus, to yield accurate prediction results, performance-relevant properties and behaviour of the infrastructure have to be integrated into performance models. However, capturing these properties is a cumbersome and error-prone task, as it requires carefully engineered measurements and experiments. Existing approaches for creating infrastructure performance models require manual coding of these experiments, or ignore the detailed properties in the models. The contribution of this paper is the Ginpex approach, which introduces goal-oriented and model-based specification and generation of executable performance experiments for detecting and quantifying performance relevant infrastructure properties. Ginpex provides a metamodel for experiment specification and comes with pre-defined experiment templates that provide automated experiment execution on the target platform and also automate the evaluation of the experiment results. We evaluate Ginpex using two case studies, where experiments are executed to detect the operating system scheduler timeslice length, and to quantify the CPU virtualization overhead for an application executed in a virtualized environment. © 2011 ACM. (26 refs)
Main heading: Experiments
Controlled terms: Forecasting - Software architecture - Specifications - Virtual reality
Uncontrolled terms: Accurate prediction - Error prones - Goal-oriented - infrastructure - Manual coding - Meta model - Model-based specifications - Performance experiment - Performance Model - Performance prediction - Software performance engineerings - Timeslice - Virtualizations - Virtualized environment
Classification Code: 723 Computer Software, Data Handling and Applications - 901.3 Engineering Research - 902.2 Codes and Standards - 921 Mathematics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
24. How software architecture can make an application-friendly internet
Zave, Pamela (1)
Source: CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11, p 1-2, 2011, CompArch’11 - Proceedings of the 2011 Federated Events on Component-Based Software Engineering and Software Architecture - QoSA+ISARCS’11; ISBN-13: 9781450307246; DOI: 10.1145/2000259.2000261; Conference: 7th Int. ACM SIGSOFT Conf. on the Quality of Software Archit., QoSA 2011 and the 2nd ACM SIGSOFT Int. Symp. on Archit. Critical Syst., ISARCS 2011, Part of the 2011 Federated Events on Component-Based Software Eng. and Software Archit., CompArch’11, June 20, 2011 - June 24, 2011; Sponsor: Assoc. Comput. Mach., Spec. Interest Group; Softw. Eng. (ACM SIGSOFT); Publisher: Association for Computing Machinery
Author affiliation: (1) AT and T Laboratories - Research, Florham Park, NJ, United States
Abstract: It is widely agreed that the Internet has outgrown its original architecture, and does not meet current or future needs in many areas. Most notably, requirements for network functionality, quality of service, security, and resource management are becoming too diverse for the classic IP layers. Consequently, the Internet is evolving toward a diversity of virtual networks, each with its own customized stack of layers or “overlays.” This evolving architecture provides opportunities to make networked applications easier to build, deploy, and maintain. To take advantage of these opportunities, however, we need answers to many questions concerning the specification, construction, verification, and dynamic composition of overlays. This talk describes new results on overlays and architectural support for mobility. A few patterns explain the exact nature of mobility, the major implementation strategies, and how different instances of mobility can be composed and transformed. Although mobility support is only one of many Internet requirements, these preliminary results suggest that a rigorous study of overlays can lead to useful new architectural principles, as well as contribute to bridging the gap between software engineering and networking. © 2011 Author. (12 refs)
Main heading: Software architecture
Controlled terms: Internet - Internet protocols - Network architecture - Quality of service - Telecommunication networks
Uncontrolled terms: Architectural principles - Architectural support - Dynamic composition - Implementation strategies - Mobility supports - Network functionality - Networked applications - New results - Resource management - Virtual networks
Classification Code: 716 Telecommunication; Radar, Radio and Television - 717 Optical Communication - 718 Telephone Systems and Related Technologies; Line Communications - 722 Computer Systems and Equipment - 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	


