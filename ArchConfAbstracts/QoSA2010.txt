	
4. Statistical inference of software performance models for parametric performance completions
Happe, Jens (1); Westermann, Dennis (1); Sachs, Kai (2); Kapová, Lucia (3)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 20-35, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_4; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) SAP Research, CEC Karlsruhe, Germany (2) TU Darmstadt, Germany (3) Karlsruhe Institute of Technology (KIT), Germany
Abstract: Software performance engineering (SPE) enables software architects to ensure high performance standards for their applications. However, applying SPE in practice is still challenging. Most enterprise applications include a large software basis, such as middleware and legacy systems. In many cases, the software basis is the determining factor of the system’s overall timing behavior, throughput, and resource utilization. To capture these influences on the overall system’s performance, established performance prediction methods (model-based and analytical) rely on models that describe the performance-relevant aspects of the system under study. Creating such models requires detailed knowledge on the system’s structure and behavior that, in most cases, is not available. In this paper, we abstract from the internal structure of the system under study. We focus on message-oriented middleware (MOM) and analyze the dependency between the MOM’s usage and its performance. We use statistical inference to conclude these dependencies from observations. For ActiveMQ 5.3, the resulting functions predict the performance with a relative mean square error 0.1. © 2010 Springer-Verlag. (30 refs)
Main heading: Mathematical models
Controlled terms: Computer software selection and evaluation - Legacy systems - Management information systems - Middleware - Software architecture - Standards - Statistical methods
Uncontrolled terms: Enterprise applications - Internal structure - Message oriented middleware - Model-based - Parametric performance - Performance prediction - Performance standards - Relative mean square errors - Resource utilizations - Software architects - Software performance engineerings - Software performance models - Statistical inference - System’s performance
Classification Code: 922.2 Mathematical Statistics - 921 Mathematics - 912.2 Management - 902.2 Codes and Standards - 723.5 Computer Applications - 723.2 Data Processing and Image Processing - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications - 722 Computer Systems and Equipment
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
5. Parameterized reliability prediction for component-based software architectures
Brosch, Franz (1); Koziolek, Heiko (2); Buhnova, Barbora (3); Reussner, Ralf (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 36-51, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_5; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) FZI Karlsruhe, Haid-und-Neu-Str. 10-14, 76131 Karlsruhe, Germany (2) ABB Corporate Research, Wallstadter Str. 59, 68526 Ladenburg, Germany (3) Masaryk University, Botanicka 68a, 60200 Brno, Czech Republic
Abstract: Critical properties of software systems, such as reliability, should be considered early in the development, when they can govern crucial architectural design decisions. A number of design-time reliability-analysis methods has been developed to support this task. However, the methods are often based on very low-level formalisms, and the connection to different architectural aspects (e.g., the system usage profile) is either hidden in the constructs of a formal model (e.g., transition probabilities of a Markov chain), or even neglected (e.g., resource availability). This strongly limits the applicability of the methods to effectively support architectural design. Our approach, based on the Palladio Component Model (PCM), integrates the reliability-relevant architectural aspects in a highly parameterized UML-like model, which allows for transparent evaluation of architectural design options. It covers the propagation of the system usage profile throughout the architecture, and the impact of the execution environment, which are neglected in most of the existing approaches. Before analysis, the model is automatically transformed into a formal Markov model in order to support effective analytical techniques to be employed. The approach has been validated against a reliability simulation of a distributed Business Reporting System. © 2010 Springer-Verlag. (25 refs)
Main heading: Quality assurance
Controlled terms: Architectural design - Availability - Computer software selection and evaluation - Markov processes - Reliability analysis - Security of data - Software architecture - Software reliability - Structural design
Uncontrolled terms: Analysis method - Analytical techniques - Component model - Component-based software architecture - Critical properties - Execution environments - Formal model - Markov Chain - Markov model - Parameterized - Reliability prediction - Reliability simulation - Reporting systems - Resource availability - Software systems - Transition probabilities
Classification Code: 922.1 Probability Theory - 913.5 Maintenance - 913.3 Quality Assurance and Control - 913.1 Production Engineering - 913 Production Planning and Control; Manufacturing - 912.2 Management - 723.5 Computer Applications - 723.2 Data Processing and Image Processing - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications - 422.2 Strength of Building Materials : Test Methods - 408.1 Structural Design, General - 402 Buildings and Towers
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
6. Good architecture = Good (ADL + practices)
Le Gloahec, Vincent (1, 3); Fleurquin, Régis (2); Sadou, Salah (3)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 167-182, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_13; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Alkante SAS, Rennes, France (2) IRISA/Triskell, Campus Universitaire de Beaulieu, Rennes, France (3) Valoria, Université de Bretagne-Sud, Vannes, France
Abstract: In order to ensure the quality of their software development process, companies incorporate best practices from recognized repositories or from their own experiences. These best practices are often described in software quality manuals that do not guarantee their implementation. In this paper, we propose a framework for the implementation of best practices concerning the design of the software architecture. We treat the case of architecture design activity because it’s the basis of the software development process. Our framework enables on the one hand to describe best practices and on the other hand to check their application by designers. We present an implementation of our framework in the Eclipse platform and for an ADL dedicated to Web applications. Finally, we give an example of use from the context of our industrial partner. © 2010 Springer-Verlag. (22 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Design - Software design
Uncontrolled terms: Architecture designs - Best practice - Design softwares - Industrial partners - Software development process - Software Quality - WEB application
Classification Code: 408 Structural Design - 723 Computer Software, Data Handling and Applications - 723.1 Computer Programming - 723.5 Computer Applications - 902.1 Engineering Graphics - 912.2 Management
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
7. Architecture-driven reliability and energy optimization for complex embedded systems
Meedeniya, Indika (1); Buhnova, Barbora (2); Aleti, Aldeida (1); Grunske, Lars (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 52-67, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_6; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Faculty of ICT, Swinburne University of Technology, Hawthorn, VIC 3122, Australia (2) Faculty of Informatics, Masaryk University, 60200 Brno, Czech Republic
Abstract: The use of redundant computational nodes is a widely used design tactic to improve the reliability of complex embedded systems. However, this redundancy allocation has also an effect on other quality attributes, including energy consumption, as each of the redundant computational nodes requires additional energy. As a result, the two quality objectives are conflicting. The approach presented in this paper applies a multi-objective optimization strategy to find optimal redundancy levels for different architectural elements. It is implemented in the ArcheOpterix tool and illustrated on a realistic case study from the automotive domain. © 2010 Springer-Verlag. (34 refs)
Main heading: Software architecture
Controlled terms: Computer software - Embedded systems - Multiobjective optimization - Quality assurance - Redundancy
Uncontrolled terms: Architectural element - Automotive domains - Computational nodes - Energy consumption - Energy optimization - Optimal redundancy - Quality attributes - Redundancy allocation
Classification Code: 921.5 Optimization Techniques - 914 Safety Engineering - 913.3 Quality Assurance and Control - 903 Information Science - 731.1 Control Systems - 723.5 Computer Applications - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications - 722 Computer Systems and Equipment
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
8. Using QoS-contracts to drive architecture-centric self-adaptation
Chauvel, Franck (1); Song, Hui (1); Chen, Xiangping (1); Huang, Gang (1); Mei, Hong (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 102-118, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_9; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Key Laboratory of High Confidence Software Technologies, School of Electronics Engineering and Computer Science, Peking University, Beijing, 100871, China
Abstract: Self-adaptation is now a promising approach to maximize the satisfaction of requirements under changing environmental conditions. One of the key challenges for such self-adaptive systems is to automatically find a relevant architectural configuration. Existing approaches requires a set of adaptation strategies and the rough estimation of their side-effects. However, due to the lack of validation methods for such strategies and side-effects, existing approaches may lead to erroneous adaptations. Instead of side-effects, our solution leverages quality contracts whose accuracy can be separately established and which can be dynamically composed to get a quality prediction of any possible architectural configurations. To support self-adaptation, we propose a reactive planning algorithm which exploits quality contracts to dynamically discover unforeseen architectural configurations. We illustrate our approach using a running HTTP server adapting its architecture with respect to the number and the similarity of incoming requests. © 2010 Springer-Verlag. (21 refs)
Main heading: Software architecture
Controlled terms: Adaptive systems - Computer software
Uncontrolled terms: Adaptation strategies - Environmental conditions - ITS architecture - Quality prediction - Reactive planning - Rough estimation - Self adaptation - Self-adaptive system - Side effect - Validation methods
Classification Code: 723 Computer Software, Data Handling and Applications - 723.1 Computer Programming - 723.4 Artificial Intelligence - 723.5 Computer Applications - 731.1 Control Systems
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
9. QoS driven dynamic binding in-the-many
Ghezzi, Carlo (1); Motta, Alfredo (1); Panzica La Manna, Valerio (1); Tamburrelli, Giordano (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 68-83, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_7; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Politecnico di Milano, Dipartimento di Elettronica e Informazione, Deep-SE Group, Via Golgi 42, 20133 Milano, Italy
Abstract: Modern software systems are increasingly built out of services that are developed, deployed, and operated by independent organizations, which expose them for the use by potential clients. Services may be directly invoked by clients. They may also be composed by service integrators, who in turn expose the composite artifact as a new service. We envision a world in which multiple providers publish software artifacts which compete with each other by implementing the same “abstract” service (i.e. they export the same API and provide the same functionality), but offering different quality of service. Clients may therefore select the most appropriate services targeting their requirements, among all the competing alternatives, and they may do so dynamically. This situation may be called dynamic binding in-the-many. Service selection may be performed by clients by following different strategies, which may in turn affect the overall quality of service invocations. In this paper we address the problem of analyzing and comparing different service selection strategies and we define a framework to model the different scenarios. Furthermore, we report on quantitative analyses through simulations of the modeled scenarios, highlighting advantages and limitations of each solution. © 2010 Springer-Verlag. (12 refs)
Main heading: Telecommunication services
Controlled terms: Computer software selection and evaluation - Quality control - Quality of service - Software architecture
Uncontrolled terms: Different services - Dynamic binding - New services - Overall quality - Quantitative analysis - Service selection - Software artifacts - Software systems
Classification Code: 912.2 Management - 723.5 Computer Applications - 723.1 Computer Programming - 913.3 Quality Assurance and Control - 723 Computer Software, Data Handling and Applications - 717 Optical Communication - 716 Telecommunication; Radar, Radio and Television - 718 Telephone Systems and Related Technologies; Line Communications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
10. A hybrid approach for multi-attribute QoS optimisation in component based software systems
Martens, Anne (1); Ardagna, Danilo (2); Koziolek, Heiko (3); Mirandola, Raffaela (2); Reussner, Ralf (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 84-101, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_8; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Karlsruhe Institute of Technology, Karlsruhe, Germany (2) Politecnico di Milano, Dipartimento di Elettronica e Informazione, Milano, Italy (3) ABB Corporate Research, Ladenburg, Germany
Abstract: Design decisions for complex, component-based systems impact multiple quality of service (QoS) properties. Often, means to improve one quality property deteriorate another one. In this scenario, selecting a good solution with respect to a single quality attribute can lead to unacceptable results with respect to the other quality attributes. A promising way to deal with this problem is to exploit multi-objective optimization where the objectives represent different quality attributes. The aim of these techniques is to devise a set of solutions, each of which assures a trade-off between the conflicting qualities. To automate this task, this paper proposes a combined use of analytical optimization techniques and evolutionary algorithms to efficiently identify a significant set of design alternatives, from which an architecture that best fits the different quality objectives can be selected. The proposed approach can lead both to a reduction of development costs and to an improvement of the quality of the final system. We demonstrate the use of this approach on a simple case study. © 2010 Springer-Verlag. (36 refs)
Main heading: Computer software selection and evaluation
Controlled terms: Evolutionary algorithms - Multiobjective optimization - Quality of service - Software architecture
Uncontrolled terms: Best fit - Component based systems - Component-based software systems - Design alternatives - Design decisions - Development costs - Hybrid approach - Multi-attributes - Multiple quality - Optimisations - Optimization techniques - Quality attributes - Quality properties
Classification Code: 921.5 Optimization Techniques - 921 Mathematics - 912.2 Management - 723.5 Computer Applications - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications - 718 Telephone Systems and Related Technologies; Line Communications - 717 Optical Communication - 716 Telecommunication; Radar, Radio and Television
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
11. Evaluating maintainability with code metrics for model-to-model transformations
Kapová, Lucia (1, 2); Goldschmidt, Thomas (1, 2); Becker, Steffen (1, 2); Henss, Jörg (1, 2)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 151-166, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_12; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Departmet for Software Design and Quality, Universität Karlsruhe (TH), 76131 Karlsruhe, Germany (2) FZI Forschungszentrum Informatik, 76131 Karlsruhe, Germany
Abstract: Using model-to-model transformations to generate analysis models or code from architecture models is sought to promote compliance and reuse of components. The maintainability of transformations is influenced by various characteristics - as with every programming language artifact. Code metrics are often used to estimate code maintainability. However, most of the established metrics do not apply to declarative transformation languages (such as QVT Relations) since they focus on imperative (e.g. object-oriented) coding styles. One way to characterize the maintainability of programs are code metrics. However, the vast majority of these metrics focus on imperative (e.g., object-oriented) coding styles and thus cannot be reused as-is for transformations written in declarative languages. In this paper we propose an initial set of quality metrics to evaluate transformations written in the declarative QVT Relations language. We apply the presented set of metrics to several reference transformations to demonstrate how to judge transformation maintainability based on our metrics. © 2010 Springer-Verlag. (22 refs)
Main heading: Object oriented programming
Controlled terms: Computer software selection and evaluation - Linguistics - Maintainability - Quality control - Query languages - Software architecture
Uncontrolled terms: Analysis models - Architecture models - Code metrics - Declarative Languages - Model to model transformation - Object oriented - Programming language - Quality metrics
Classification Code: 913.5 Maintenance - 913.3 Quality Assurance and Control - 912.2 Management - 903.2 Information Dissemination - 723.5 Computer Applications - 723.3 Database Systems - 723.1.1 Computer Programming Languages - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
12. Validating model-driven performance predictions on random software systems
Babka, Vlastimil (1); Tuma, Petr (1); Bulej, Lubomír (1, 2)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 3-19, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_3; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Department of Distributed and Dependable Systems, Faculty of Mathematics and Physics, Charles University, Malostranské námêstí 25, 118 00 Prague, Czech Republic (2) Institute of Computer Science, Academy of Sciences of the Czech Republic, Pod Vodárenskou vezí 2, 182 07 Prague, Czech Republic
Abstract: Software performance prediction methods are typically validated by taking an appropriate software system, performing both performance predictions and performance measurements for that system, and comparing the results. The validation includes manual actions, which makes it feasible only for a small number of systems. To significantly increase the number of systems on which software performance prediction methods can be validated, and thus improve the validation, we propose an approach where the systems are generated together with their models and the validation runs without manual intervention. The approach is described in detail and initial results demonstrating both its benefits and its issues are presented. © 2010 Springer-Verlag. (33 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Forecasting
Uncontrolled terms: Manual intervention - Model-driven - Performance measurements - Performance Modeling - Performance prediction - Software performance - Software systems
Classification Code: 723 Computer Software, Data Handling and Applications - 723.1 Computer Programming - 723.5 Computer Applications - 912.2 Management - 921 Mathematics - 922.2 Mathematical Statistics
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
13. Barriers to modularity - An empirical study to assess the potential for modularisation of Java programs
Dietrich, Jens (1); McCartin, Catherine (1); Tempero, Ewan (2); Ali Shah, Syed M. (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 135-150, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_11; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Massey University, School of Engineering and Advanced Technology, Palmerston North, New Zealand (2) Department of Computer Science, University of Auckland, Auckland, New Zealand
Abstract: To deal with the challenges when building large and complex systems modularisation techniques such as component-based software engineering and aspect-oriented programming have been developed. In the Java space these include dependency injection frameworks and dynamic component models such as OSGi. The question arises as to how easy it will be to transform existing systems to take advantage of these new techniques. Anecdotal evidence from industry suggests that the presence of certain patterns presents barriers to refactoring of monolithic systems into a modular architecture. In this paper, we present such a set of patterns and analyse a large set of open-source systems for occurrences of these patterns. We use a novel, scalable static analyser that we have developed for this purpose. The key findings of this paper are that almost all programs investigated have a significant number of these patterns, implying that modularising will be therefore difficult and expensive. © 2010 Springer-Verlag. (38 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Computer systems programming - Java programming language - Wavelet transforms
Uncontrolled terms: Anecdotal evidences - Aspect-Oriented Programming - Complex systems - Component-based software engineering - Dependency injection - Dynamic component - Empirical studies - Existing systems - Java program - Modular architectures - Monolithic systems - Open source system - Refactorings
Classification Code: 723 Computer Software, Data Handling and Applications - 723.1 Computer Programming - 723.1.1 Computer Programming Languages - 723.5 Computer Applications - 912.2 Management - 921.3 Mathematical Transformations
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
14. Is BPMN really first choice in joint architecture development? An empirical study on the usability of BPMN and UML activity diagrams for business users
Birkmeier, Dominik (1); Overhage, Sven (1)
Source: Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), v 6093 LNCS, p 119-134, 2010, Research Into Practice - Reality and Gaps - 6th International Conference on the Quality of Software Architectures, QoSA 2010, Proceedings; ISSN: 03029743, E-ISSN: 16113349; ISBN-10: 3642138209, ISBN-13: 9783642138201; DOI: 10.1007/978-3-642-13821-8_10; Conference: 6th International Conference on the Quality of Software Architectures, QoSA 2010, June 23, 2010 - June 25, 2010; Publisher: Springer Verlag
Author affiliation: (1) Component and Service Engineering Group, Business Informatics and Systems Engineering Department, University of Augsburg, Universitaetsstrasse 16, 86159 Augsburg, Germany
Abstract: Joint architecture development plays a key role in service-oriented computing as it facilitates the coordination of business processes with the software architectures of applications. To better support business users in the communication of business process semantics, the Object Management Group advises to adopt the newly standardized Business Process Modeling Notation (BPMN) instead of the UML Activity Diagram. A main reason for this advice is that BPMN is presumed to be more usable for business users than the technically-oriented Activity Diagram. Adopting a new process modeling language, however, is a significant expense factor for businesses and consolidated findings on whether such presumptions hold true in practice are missing. In this paper, we present results from an empirical study, in which we examined the application of BPMN and the UML Activity Diagram by business users during a model creation task. Results indicate that the UML Activity Diagram is at least as usable as BPMN since neither user effectiveness, efficiency, nor satisfaction differ significantly. © 2010 Springer-Verlag. (31 refs)
Main heading: Software architecture
Controlled terms: Computer software selection and evaluation - Systems analysis
Uncontrolled terms: Activity diagram - Business Process - Business process modeling - Business-users - Empirical studies - Joint architectures - Model creation - New process - Object management groups - Service oriented computing - UML activity diagrams
Classification Code: 961 Systems Science - 912.3 Operations Research - 912.2 Management - 731.1 Control Systems - 723.5 Computer Applications - 723.1 Computer Programming - 723 Computer Software, Data Handling and Applications
Database: Compendex
Compilation and indexing terms, Copyright 2015 Elsevier Inc.
Data Provider: Engineering Village
	
15. Intrinsic Definition in Software Architecture Evolution
Magee, J.N. (1)
Source: Research into Practice - Reality and Gaps. Proceedings 6th International Conference on the Quality of Software Architectures, QoSA 2010, p 1 pp., 2010; ISBN-13: 978-3-642-13820-1; Conference: Research into Practice - Reality and Gaps. 6th International Conference on the Quality of Software Architectures, QoSA 2010, 23-25 June 2010, Prague, Czech Republic; Publisher: Springer Verlag, Berlin, Germany
Author affiliation: (1) Imperial Coll. London, London, United Kingdom
Abstract: Incremental change is intrinsic to both the initial development and subsequent evolution of large complex software systems. The talk discusses both, the requirements for and the design of, an approach that captures this incremental change in the definition of software architecture. The predominate advantage in making the definition of evolution intrinsic to architecture description is in permitting a principled and manageable way of dealing with unplanned change and extension. Intrinsic definition also facilitates decentralized evolution in which software is extended and evolved by multiple independent developers. The objective is an approach which permits unplanned extensions to be deployed to end users with the same facility that plugin extensions are currently added to systems with planned extension points. The talk advocates a model-driven approach in which architecture definition is used to directly construct both initial implementations and extensions / modification to these implementations. An implementation of intrinsic evolution definition in Backbone is presented - an architectural description language (ADL), which has both a textual and a UML2, based graphical representation. The talk uses Backbone to illustrate basic concepts through simple examples and reports experience in applying it and its associated tool support to larger examples. (0 refs)
Inspec controlled terms: large-scale systems - software architecture
Uncontrolled terms: software architecture - complex software systems - model-driven approach - architectural description language - ADL - graphical representation
Classification Code: C6110B Software engineering techniques
IPC Code: G06F9/44
Treatment: Practical (PRA)
Database: Inspec
Copyright 2010, The Institution of Engineering and Technology
Data Provider: Engineering Village
	
16. A Component-Based Approach to Adaptive User-Centric Pervasive Applications
Wirsing, M. (1)
Source: Research into Practice - Reality and Gaps. Proceedings 6th International Conference on the Quality of Software Architectures, QoSA 2010, p 181, 2010; ISBN-13: 978-3-642-13820-1; Conference: Research into Practice - Reality and Gaps. 6th International Conference on the Quality of Software Architectures, QoSA 2010, 23-25 June 2010, Prague, Czech Republic; Publisher: Springer Verlag, Berlin, Germany
Author affiliation: (1) Ludwig-Maximilians-Univ. Munich, Munich, Germany
Abstract: In the last years computing has become omnipresent and even devices that do not look like computers have computing capabilities. Seamless man-machine interfaces and ad-hoc communication allow for pervasive adaptive control and computer support in everyday activities. So-called pervasive-adaptive environments are becoming able to monitor, diagnose and respond to the cognitive, emotional and physical states of persons in real time. In this talk we present a new approach for designing and realising adaptive systems that provide assistance to humans in a discrete and personalized manner. The approach is based on a strict component-based framework for controlling pervasive adaptive systems including real-time sensor and actuator control, user and context-awareness, affective computing, self-organization and adaptation. A rule-based domain-specific language simplifies the dynamic creation and modification of system architectures; mechanisms for the transparent distribution of applications, flexible on-line data processing, and early experimentation with data analysis algorithms facilitate the construction of user-centric adaptive systems while a modular assume/guarantee framework allows to compute formal representation of such systems and to verify them against given system requirements. We illustrate our approach by two case studies for detecting cognitive overload and influencing the mood of a user in the way he desires. (0 refs)
Inspec controlled terms: adaptive control - adaptive systems - data analysis - formal specification - knowledge based systems - ubiquitous computing
Uncontrolled terms: component-based approach - adaptive user-centric pervasive applications - adaptive systems design - pervasive adaptive systems control - real-time sensor - actuator control - rule-based domain-specific language - data analysis algorithms - formal representation
Classification Code: C6150N Distributed systems software - C1340E Self-adjusting control systems - C6170 Expert systems and other AI software and techniques - C6130 Data handling techniques - C6110F Formal methods
IPC Code: G05B13/00 - G06F7/00 - G06F9/44 - G06F9/46 - G06F15/18
Treatment: Practical (PRA)
Database: Inspec
Copyright 2010, The Institution of Engineering and Technology
Data Provider: Engineering Village
	


