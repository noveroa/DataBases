Proceedings Working IEEE/IFIP Conference on Software Architecture," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.iii,, 28-31 Aug. 2001
doi: 10.1109/WICSA.2001.948397
Abstract: The following topics are dealt with: software architecture; industrial case studies; software quality; product lines; formal methods; representation; software components, connectors and collaborations; patterns and software tools
keywords: {software architecture;software quality;software reusability;software tools;collaborations;formal methods;industrial case studies;product lines;representation;software architecture;software components;software connectors;software patterns;software quality;software tools},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948397&isnumber=20517

Author index," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.201,201, 31-31 Aug. 2001
doi: 10.1109/WICSA.2001.948430
Abstract: The author index contains an entry for each author and coauthor included in the proceedings record.
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948430&isnumber=20517

Stoermer, C.; O'Brien, L., "MAP - mining architectures for product line evaluations," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.35,44, 2001
doi: 10.1109/WICSA.2001.948405
Abstract: Product lines evolve out of existing products. In order to evaluate the potential of creating a product line from existing products, it is necessary to 'mine' their architectures and analyze the commonalities and variabilities across those architectures. To manage the evaluation process in a disciplined way the paper introduces the MAP (Mining Architectures for Product Lines) method. MAP outlines a bottom-up approach for mining the architecture of the existing products, a top-down approach to mapping architectural styles and attributes onto the mined architectures and an approach to analyzing their commonalities and variabilities. It combines well-known architecture reconstruction and product line analysis techniques. A case study is presented showing the application of the method and its benefits are outlined
keywords: {DP industry;manufacturing data processing;software architecture;systems analysis;MAP;Mining Architectures for Product Lines method;architectural styles;architecture reconstruction;bottom-up approach;case study;evaluation process;mining architectures;product line evaluations;top-down approach;Acceleration;Asset management;Computer architecture;Costs;Documentation;Hardware;Memory management;Software engineering;Timing;USA Councils},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948405&isnumber=20517

Spitznagel, B.; Garlan, D., "A compositional approach for constructing connectors," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.148,157, 2001
doi: 10.1109/WICSA.2001.948424
Abstract: Increasingly, systems are composed from independently developed parts, and mechanisms that allow those parts to interact (connectors). In many situations, specialized forms of interaction are needed to bridge component mismatches or to achieve extra-functional properties (e.g., security, performance, reliability), making the design and implementation of these interaction mechanisms a critical issue. Unfortunately, system developers have few options: they must live with available, but often inadequate, generic support for interaction (such as RPC), or they must handcraft specialized mechanisms at great cost. The authors describe a partial solution to this problem, whereby interaction mechanisms are constructed compositionally. Specifically, we describe a set of operators that can transform generic communication mechanisms (such as RPC and publish-subscribe) to incrementally add new capabilities. We show how these transformations can be used to realize complex interactions (such as Kerberized RPC) and to generate implementations of the new connector types at relatively low cost
keywords: {application program interfaces;network operating systems;object-oriented programming;protocols;remote procedure calls;software architecture;Kerberized RPC;component mismatches;compositional approach;compositional interaction mechanism design;connector construction;extra-functional properties;generic support;independently developed parts;interaction mechanism design;publish-subscribe;specialized interaction;specialized mechanisms;system developers;Bridges;Client-server systems;Connectors;Costs;Data security;Databases;Mechanical factors;Publish-subscribe;Software reusability;Software systems},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948424&isnumber=20517

Shaw, M., "When system boundaries dissolve: research opportunities in software architectures for ubiquitous computing and communication," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.99,99, 2001
doi: 10.1109/WICSA.2001.948414
Abstract: Not Available
keywords: {Communication system control;Computer applications;Computer architecture;Computer science;Control systems;Pervasive computing;Software architecture;Software engineering;Software systems;Ubiquitous computing},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948414&isnumber=20517

Chang, N.Z.; Cungang Yang, "An object-oriented RBAC model for distributed system," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.24,32, 2001
doi: 10.1109/WICSA.2001.948401
Abstract: In distributed computing environments, users would like to share resources and communicate with each other to perform their jobs more efficiently. For better performance, it is important to keep resources and information integrity from unexpected use by unauthorized users. Therefore, there is a strong demand for access control of distributed shared resources. Role-Based-Access-Control (RBAC) has been introduced and offers a powerful means for specifying access control decisions. The authors propose an object oriented RBAC model for distributed system (ORBAC), it efficiently represents the real world. Moreover, under the decentralized ORBAC management architecture, an implementation of the model has realized multiple-domain access control. Finally, statically and dynamically role authorization is considered and a method to deal with the problem of separation of duties is presented
keywords: {authorisation;distributed object management;object-oriented programming;resource allocation;shared memory systems;Role-Based-Access-Control;access control;access control decisions;decentralized ORBAC management architecture;distributed computing environments;distributed shared resources;distributed system;information integrity;multiple domain access control;object oriented RBAC model;resource sharing;role authorization;separation of duties;unauthorized users;unexpected use;Access control;Authorization;Computer science;Costs;Humans;Logic;Object oriented modeling;Protection;Qualifications;Security},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948401&isnumber=20517

Kozaczynski, W., "Is architecture a product that can be packaged and sold?," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.3,3, 2001
doi: 10.1109/WICSA.2001.948398
Abstract: Not Available
keywords: {Application software;Biographies;Buildings;Collaborative software;Computer architecture;Computer industry;Manufacturing industries;Packaging;Software engineering;Software packages},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948398&isnumber=20517

Jonkers, H., "Interface-centric architecture descriptions," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.113,124, 2001
doi: 10.1109/WICSA.2001.948418
Abstract: The paper presents an approach to defining component-based software architectures in which interfaces rather than components play the key role. Architectural descriptions are built from 'i-specs' that define interface-level interaction patterns. An i-spec can be seen as a contract defining the rights and obligations of 'roles' that can be played in interface-based interactions. We introduce the 'closed world assumption' for i-specs, leading to a compositional approach to defining software architectures. We show how i-specs can be composed and how component specifications can be constructed from i-specs
keywords: {interactive systems;object-oriented programming;software architecture;user interfaces;architectural descriptions;closed world assumption;component based software architectures;component specifications;compositional approach;contract;i-specs;interface-based interactions;interface-centric architecture descriptions;interface-level interaction patterns;Concrete;Contracts;Laboratories;Protocols;Resource management;Software architecture},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948418&isnumber=20517

Dashofy, E.M.; van der Hoek, A.; Taylor, R.N., "A highly-extensible, XML-based architecture description language," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.103,112, 2001
doi: 10.1109/WICSA.2001.948416
Abstract: Software architecture research focuses on models of software architectures as specified in architecture description languages (ADLs). As research progresses in specific areas of software architectures, more and more architectural information is created. Ideally, this information can be stored in the model. An extensible modeling language is crucial to experimenting with and building tools for novel modeling constructs that arise from evolving research. Traditional ADLs typically support a small set of modeling constructs very well, but adapt to others poorly. XML provides an ideal platform upon which to develop an extensible modeling language for software architectures. Previous XML-based ADLs successfully leveraged XML's large base of off-the-shelf tool support, but did not take advantage of its extensibility. To give software architecture researchers more freedom to explore new possibilities and modeling techniques, while maximizing reuse of tools and modeling constructs, we have developed xADL 2.0, a highly extensible XML-based ADL. xADL 2.0 supports run-time and design time modeling, architecture configuration management and model-based system instantiation. Additionally, xADL 2.0 has a set of extensible infrastructure tools that support the creation, manipulation, and sharing of xADL 2.0 documents
keywords: {hypermedia markup languages;software architecture;software reusability;specification languages;ADLs;XML-based ADLs;architectural information;architecture configuration management;architecture description languages;design time modeling;extensible infrastructure tools;extensible modeling language;highly extensible XML based architecture description language;model-based system instantiation;modeling constructs;modeling techniques;off-the-shelf tool support;software architecture specification;software reuse;xADL 2;Architecture description languages;Buildings;Computer architecture;Computer science;Connectors;Military computing;Runtime;Software architecture;Software development management;XML},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948416&isnumber=20517

Geppert, B.; Rossler, F., "Collaboration-based design - exemplified by the Internet Session Initiation Protocol (SIP)," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.158,167, 2001
doi: 10.1109/WICSA.2001.948425
Abstract: The concept of collaborations capturing dynamic aspects of a distributed system across agent boundaries is introduced. Some ways of composing collaborations are illustrated, with collaborations being implicitly represented as state machine fragments. The concepts are exemplified by the Internet Session Initiation Protocol (SIP) and consequences for a potential SIP implementation are discussed
keywords: {Internet;groupware;protocols;software agents;specification languages;Internet SIP;Internet Session Initiation Protocol;SIP implementation;agent boundaries;collaboration-based design;distributed system;dynamic aspects;protocol architectures;state machine fragments;Automata;Collaboration;Collaborative software;Collaborative work;Computer science;Internet;Object oriented modeling;Object oriented programming;Protocols;Software architecture},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948425&isnumber=20517

Mitchell, B.; Traverso, M.; Mancoridis, S., "An architecture for distributing the computation of software clustering algorithms," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.181,190, 2001
doi: 10.1109/WICSA.2001.948427
Abstract: Collections of general purpose networked workstations offer processing capability that often rivals or exceeds supercomputers. Since networked workstations are readily available in most organizations, they provide an economic and scalable alternative to parallel machines. The authors discuss how individual nodes in a computer network can be used as a collection of connected processing elements to improve the performance of a software engineering tool that we developed. Our tool, called Bunch, automatically clusters the structure of software systems into a hierarchy of subsystems. Clustering helps developers understand complex systems by providing them with high-level abstract (clustered) views of the software structure. The algorithms used by Bunch are computationally intensive and, hence, we would like to improve our tool's performance in order to cluster very large systems. The paper describes how we designed and implemented a distributed version of Bunch, which is useful for clustering large systems
keywords: {automatic programming;distributed programming;software architecture;software tools;workstation clusters;Bunch;automatic software system clustering;computation distribution architecture;computer network;connected processing elements;distributed version;economic alternative;general purpose networked workstations;high-level abstract views;individual nodes;parallel machines;processing capability;scalable alternative;software clustering algorithms;software engineering tool;software structure;subsystem hierarchy;supercomputers;very large systems;Application software;Clustering algorithms;Computer architecture;Computer networks;Distributed computing;Documentation;Independent component analysis;Software algorithms;Software systems;Software tools},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948427&isnumber=20517

Schwanke, R.W., "Layers, decisions, patterns, styles, and architectures," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.137,147, 2001
doi: 10.1109/WICSA.2001.948423
Abstract: The pattern-composition diagram and the attribute/decision graph summarize an architecture and its rationale, respectively. The paper introduces, defines, and discusses these notations, with an example of a reference architecture for a broad class of real-time systems. The design patterns organizing the infrastructure of the example system would be highly recommended for most large systems today, and are therefore nominated as "foundational architectural patterns"
keywords: {computational linguistics;graph theory;object-oriented programming;real-time systems;software architecture;attribute/decision graph;foundational architectural patterns;large systems;pattern-composition diagram;real-time systems;reference architecture;software architecture;Application software;Computer architecture;Engineering drawings;Hardware;Organizing;Real time systems;Software architecture;Software design;Software engineering;Software standards},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948423&isnumber=20517

Sotirovski, D., "Towards fault-tolerant software architectures," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.7,13, 2001
doi: 10.1109/WICSA.2001.948399
Abstract: "Software engineering has produced no effective methods to eradicate latent software faults. " This sentence is, of course, a stereotype, but it is as true as a stereotype can get. And yet, it begs some questions. If it is not possible to construct a large software system without residual faults, is it at least possible to construct it to degrade gracefully if and when a latent fault is encountered? This paper presents the approach adopted on CAATS (Canadian Automated Air Traffic System), and argues that OO design and certain architectural properties are the enabling elements towards a true fault-tolerant software architecture
keywords: {object-oriented programming;software architecture;software fault tolerance;Canadian Automated Air Traffic System;architectural properties;fault-tolerant software architectures;object oriented design;software system;Computer architecture;Degradation;Design engineering;Fault detection;Fault tolerance;Fault tolerant systems;Software engineering;Software safety;Software systems;Traffic control},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948399&isnumber=20517

Laine, P.K., "The role of SW architecture in solving fundamental problems in object-oriented development of large embedded SW systems," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.14,23, 2001
doi: 10.1109/WICSA.2001.948400
Abstract: The article approaches SW (software) architecture through the needs and problems of object oriented SW development. It is widely perceived that the OO approach, despite its generally acknowledged strengths, has so far failed to fully deliver its promises. Based on experiences from the development of several large embedded SW systems, an analysis of common practical and conceptual problems in OO SW development is performed and a solution is suggested The analysis indicates a need for SW architecture as a separate concept. The discussion of the solution concentrates on the nature of SW architecture in this context, on the methodological implications of combining SW architecture work with OO approach and on the role of the architecture task in the entirety of SW construction
keywords: {embedded systems;object-oriented programming;software architecture;OO SW development;OO approach;SW architecture;conceptual problems;large embedded SW systems;methodological implications;object oriented SW development;software architecture;Computer architecture;Embedded software;Embedded system;Failure analysis;Filling;Hardware;Laboratories;Large-scale systems;Performance analysis;Power system modeling},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948400&isnumber=20517

van Ommering, R., "Techniques for independent deployment to build product populations," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.55,64, 2001
doi: 10.1109/WICSA.2001.948407
Abstract: When building small product families, software should be shared between different members of the family, but the software can still be created as one system (with variation points) with a single architecture. For large and diverse product families (product populations), the software can no longer be developed in one context and at one moment in time. Instead, one must combine software components of which the development is separated in space and in time, each with their own evolution path. In other words, we need independent deployment of components. We discuss four aspects of independent deployment. Two of these aspects: upward and downward compatibility, deal with variation in time. The other two: reusability and portability, deal with variation in space. For each aspect, we indicate the relevance, provide some examples, and list several techniques to deal with it. The paper can thus be seen as a guide for product population development
keywords: {DP industry;software architecture;software development management;software packages;software portability;software reusability;diverse product families;downward compatibility;evolution path;independent component deployment;product population development;small product family design;software components;upward compatibility;Buildings;Computer architecture;DVD;Laboratories;Product development;System testing;Systems engineering and theory;TV},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948407&isnumber=20517

Kloukinas, C.; Issarny, V., "SPIN-ning software architectures: a method for exploring complex systems," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.67,76, 2001
doi: 10.1109/WICSA.2001.948409
Abstract: When designing complex software systems that provide multiple non-functional properties, it is usual to try to reuse (and finally compose) simpler existing designs, which deal with each of these properties in solitude. The paper describes a method for automatically and quickly identifying all the different ways one can compose such designs, with the aid of a model checker
keywords: {program debugging;program verification;software architecture;software reusability;SPIN;architectural debugging;architecture discovery;architecture transformation;complex software systems;complex systems design;model checker;multiple non-functional properties;software architectural composition;software architectures;Buildings;Computer architecture;Cost function;Debugging;Error correction;Maintenance;Middleware;Security;Software engineering;Software systems},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948409&isnumber=20517

Baragry, J.; Reed, K., "Why we need a different view of software architecture," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.125,134, 2001
doi: 10.1109/WICSA.2001.948419
Abstract: The definition and understanding of software architectures and architecture views still shows considerable disagreement in the software engineering community. The paper argues that the problems we face exist because our understanding is based on specious analogies with traditionally engineered artefacts. A review of the history of ideas shows the evolution of this understanding. A detailed examination is then presented of the differences that exist between the nature of the systems, the content of their large-scale representations, and how they are used in practice in the respective disciplines. These differences seriously undermine the analogies used to develop our understanding and this is discussed in terms of software engineering as a whole
keywords: {DP industry;history;software architecture;history;large-scale representations;software architecture understanding;software architecture view;software engineering community;traditionally engineered artefacts;Australia;Computer architecture;Computer science;History;Large-scale systems;Software architecture;Software engineering;Software systems;Systems engineering and theory;Terminology},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948419&isnumber=20517

Bernardo, M.; Ciancarini, P.; Donatiello, L., "Detecting architectural mismatches in process algebraic descriptions of software systems," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.77,86, 2001
doi: 10.1109/WICSA.2001.948411
Abstract: Formalizing the description of software systems helps to detect the presence of architectural mismatches that can arise when assembling software components together. The authors identify three causes of architectural mismatches: incompatibility between two components due to a single interaction, incompatibility between two components due to the combination of several interactions, and lack of interoperability among a set of components forming a cyclic topology. We then show how to deal with all of them within a uniform, process algebraic framework. We begin with the first two causes by strengthening a previously defined architectural compatibility check based on observational equivalences, in order to achieve a deadlock freedom result for the set of components interacting via a certain connection. We subsequently concentrate on the third cause by defining a novel architectural interoperability check based on observational equivalences, which guarantees absence of deadlock within a set of interacting components forming a cyclic topology. We finally assess the adequacy of our architectural interoperability check by applying it to the description of a cruise control system
keywords: {concurrency control;formal specification;open systems;process algebra;software architecture;system recovery;architectural compatibility check;architectural interoperability check;architectural mismatch detection;cruise control system;cyclic topology;deadlock freedom;formalized software system description;observational equivalences;process algebraic descriptions;software components;uniform process algebraic framework;Algebra;Architecture description languages;Computer architecture;Connectors;Data structures;Embedded system;Software architecture;Software engineering;Software systems;System recovery},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948411&isnumber=20517

Egyed, A.; Wile, D., "Statechart simulator for modeling architectural dynamics," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.87,96, 2001
doi: 10.1109/WICSA.2001.948413
Abstract: Software development is a constant endeavor to optimize qualities like performance and robustness while ensuring functional correctness. Architecture Description Languages (ADLs) form a foundation for modeling and analyzing functional and non-functional properties of software systems, but, short of programming, only the simulation of those models can ensure certain desired qualities and functionalities. The paper presents an adaptation to statechart simulation, as pioneered by D. Harel (1987). This extension supports architectural dynamism: the creation, replacement, and destruction of components. We distinguish between design-time dynamism, where system dynamics are statically proscribed (e.g., creation of a predefined component class in response to a trigger), and run-time dynamism, where the system is modified while it is running (e.g., replacement of a faulty component without shutting down the system). Our enhanced simulation language, with over 100 commands, is tool-supported
keywords: {object-oriented programming;program diagnostics;simulation languages;software architecture;specification languages;virtual machines;ADLs;Architecture Description Languages;architectural dynamics modeling;architectural dynamism;design-time dynamism;enhanced simulation language;faulty component;functional correctness;functional properties;non-functional properties;predefined component class;run-time dynamism;software development;statechart simulator;Architecture description languages;Computer architecture;Costs;Discrete event simulation;Programming;Robustness;Software quality;Software tools;Tellurium;Unified modeling language},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948413&isnumber=20517

Lei Ding; Medvidovic, N., "Focus: a light-weight, incremental approach to software architecture recovery and evolution," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.191,200, 2001
doi: 10.1109/WICSA.2001.948429
Abstract: During the past decade (1991-2001), object-orientation (OO) has become the dominant software development methodology, accompanied by a number of modeling notations, programming languages, and development environments. OO applications of today are increasingly complex and user driven. They are also developed more rapidly and evolved more frequently than was the case with software systems of the past. All of these factors contribute to a plethora of potential problems when maintaining and evolving an OO application. These problems are caused by architectural erosion, where the initial architecture of an application is (arbitrarily) modified to the point where its key properties no longer hold. We propose an approach, called Focus, whose goal is to enable effective evolution of such an application with minimal effort, by recovering its architecture and using it as the basis of evolution. Focus allows engineers to direct their primary attention to the part of the system that is directly impacted by the desired change; subsequent changes will incrementally uncover additional parts of the system's architecture. We have applied Focus to four off-the-shelf applications to date. We discuss its key strengths and point out several open issues that will frame our future work
keywords: {graphical user interfaces;object-oriented programming;software architecture;software prototyping;system recovery;Focus;GUI;OO application evolution;OO architecture recovery;architectural erosion;light-weight incremental approach;modeling notations;object-orientation;off-the-shelf applications;software architecture evolution;software architecture recovery;software development methodology;Application software;Computer architecture;Computer languages;Computer science;Frequency;Graphical user interfaces;Programming;Software architecture;Software quality;Software systems},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948429&isnumber=20517

van Gurp, J.; Bosch, J.; Svahnberg, M., "On the notion of variability in software product lines," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.45,54, 2001
doi: 10.1109/WICSA.2001.948406
Abstract: The authors discuss the notion of variability. We have experienced that this concept has so far been underdefined, although we have observed that variability techniques become increasingly important. A clear indication of this trend is the recent emergence of software product lines. Software product lines are large, industrial software systems intended to specialize into specific software products. The authors provide a framework of terminology and concepts regarding variability. In addition, they present three recurring patterns of variability. Finally, they suggest a method for managing variability in software product lines
keywords: {DP industry;software development management;software packages;large industrial software systems;recurring variability patterns;software product line variability;terminology;variability techniques;Computer industry;Computer science;Delay effects;Mathematics;Runtime;Software architecture;Software design;Software engineering;Software reusability;Software systems},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948406&isnumber=20517

Hakala, M.; Hautamaki, J.; Koskimies, K.; Paakki, J.; Viljamaa, A.; Viljamaa, J., "Annotating reusable software architectures with specialization patterns," Software Architecture, 2001. Proceedings. Working IEEE/IFIP Conference on , vol., no., pp.171,180, 2001
doi: 10.1109/WICSA.2001.948426
Abstract: An application framework is a collection of classes implementing the shared architecture of a family of applications. It is shown how the specialization interface ("hot spots") of a framework can be annotated with specialization patterns to provide task-based guidance for the framework specialization process. The specialization patterns define various structural, semantic, and coding constraints over the applications derived from the framework. We also present a tool that supports both the framework development process and the framework specialization process, based on the notion of specialization patterns. We outline the basic concepts of the tool and discuss techniques to identify and specify specialization patterns as required by the tool. These techniques have been applied in realistic case studies for creating programming environments for application frameworks
keywords: {object-oriented programming;programming environments;software architecture;software reusability;task analysis;application framework;application frameworks;coding constraints;framework development process;framework specialization process;hot spots;programming environments;realistic case studies;reusable software architecture annotation;shared architecture;specialization interface;specialization patterns;task-based guidance;Application software;Computer architecture;Computer science;Electronic mail;Java;Laboratories;Large-scale systems;Programming environments;Programming profession;Software reusability},
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=948426&isnumber=20517
