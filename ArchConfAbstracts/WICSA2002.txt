1. The Adaptive Object-Model Architectural Style
Joseph W. Yoder & Ralph Johnson
Software Architecture Group -
Department of Computer Science
Univ. Of illinois at Urbana-Champaign
Urbana, IL 61801
yoder@refactory.com &: johnson@cs.uiuc.edu
Abstract: We have noticed a common architecture in many systems that emphasize
flexibility and run-time configuration. In these systems, business rules are
stored externally to the program such as in a database or XML files. The
object model that the user cares about is part of the database, and the object
model of the code is just an interpreter of the users' object model. We call
these systems "Adaptive Object-Models", because the users' object model is
interpreted at runtime and can be changed with immediate (but controlled)
effects on the system interpreting it. The real power in Adaptive ObjectModels
is that the definition of a domain model and rules for its integrity can
be configured by domain experts external to the execution of the program.
These systems are important when flexibility and dynamic runtime
configuration is needed, but their architectures have yet to be described in
detail. This paper describes the Adaptive Object-Model architecture style
along with its strengths and weaknesses. It illustrates the Adaptive ObjectModel
architectural style by outlining examples of production systems.
Key words: Adaptive Object-Model, Adaptive Systems, Analysis and Design Patterns,
Domain-Specific Language, Architectural Styles, Components, Dynamic
Object-Model, Frameworks, Meta-Modeling, Meta-Architectures, Metadata,
Metalevel, Reflection, Reflective Systems.


2. Aura: An Architectural Framework for User Mobility
in Ubiquitous Computing Environments
Joio Pedro Sousa and David Garlan
School of Computer Science
Carnegie Mellon University
5000 Forbes Ave
PittsburghPA 15213 USA
(jpsousa,garlan)@cs.cmu.edu
Abstract: Ubiquitous computing poses a number of challenges for software architecture.
One of the most important is the ability to design software systems that accommodate
dynamically-changing resources. Resource variability arises naturally
in a ubiquitous computing setting through user mobility (a user moves
from one computing environment to another), and through the need to exploit
time-varying resources in a given environment (such as wireless bandwidth).
Traditional approaches to handling resource variability in applications attempt
to address the problem by imposing uniformity on the environment. We argue
that those approaches are inadequate, and describe an alternative architectural
framework that is better matched to the needs of ubiquitous computing. A key
feature of the archi~ is that user tasks become first class entities. User
proxies, or Auras, use models of user tasks to set up, monitor and adapt computing
environments proactively. The architectural framework has been implemented
and is currently being used as a central component of Project Aura,
a campus-wide ubiquitous computing effort.
Key words: Ubiquitous computing, mobility, architectural framework, architectural style.



3. Using Architectural Style as a Basis
for System Self.repair
Shang-Wen Cheng, David Garlan, Bradley Schmerl, Joao Pedro Sousa,
Bridget Spitznagel, Peter Steenkiste
School of Computer Science,
Carnegie Mellon University,
5000 Forbes Ave,
Pittsburgh PA 15213 USA
{zensoul,garlan,schmerljpsousa,sprite,prs}@cs.cmu.edu
Abstract: An increasingly important requirement for software systems is the capability
to adapt at run time in order to accommodate varying resources, system errors,
and changing requirements. For such self-repairing systems, one of the hard
problems is determining when a change is needed, and knowing what kind of
adaptation is required. Recently several researchers have explored the possibility
of using architectural models as a basis for run time monitoring, error
detection, and repair. Each of these efforts, however, has demonstrated the feasibility
of using architectural models in the context of a specific style. In this
paper we show how to generalize these solutions by making architectural style
a parameter in the monitoring/repair framework and its supporting infrastructure.
The value of this generalization is that it allows one to tailor monitoringlrepair
mechanisms to match both the properties of interest (such as performance
or security), and the available operators for run time adaptation.
Key words: Dynamic adaptation, software architectures, performance analysis.



4. Modeling and Analyzing the Software Architecture of
a Communication Protocol Using SAM
Tianjun Shi, Xudong He
School of Computer Science, Florida International University, Miami, FL 33199
Abstract: SAM is a general framework for modeling and analyzing software
architectures. In this paper, we apply SAM to model and analyze a popular
alternating-bit communication protocol. To compare with other existing
formalization of this communication protocol and to show the salient features
of SAM, we provide two specifications of the communication protocol - one
without a timer and one with a timer. Furthermore we explore two different
translation approaches using the model checking language SMV, and compare
their effectiveness. We provide some general rules, including rules to deal
with timing issues, to translate predicate transition nets into SMV
specifications so that automatic verification of systems properties through
model checking can be done.
Key words: Software architecture, formal specification and verification, model checking,
predicate transition nets, temporal logic



5. DYNAMIC RECONFIGURABLE SOFTWARE
ARCHITECTURE:
ANALYSIS AND EVALUATION
Amar RAMDANE-CHERIF 1 , Nicole LEVY 1 and Francisca LOSA VIO 1
1 PRiSM, Universite de Versailles St.-Quentin,
45, Avenue des Etats-Unis, 78035 Versailles Cedex, France.
{ amar.ramdane-cherif@prism.uvsq.frl
2 Centro ISYS, LaTecS, Universidad Central de Venezuela,
Caracas, Venezuela.
Abstract: Dynamic changes to an architecture is an active area of research within
the software architecture community. Architectures must have the ability
to react to events and perform architectural changes autonomously. In
this paper, we focus on dynamic architectures reconfiguration. Our
principle is to use the agent architectural concept to achieve this
functionality with respect to some quality attributes. Hence the questions
that we are currently facing: what are the architectural principles
involved in building adaptable architecture? How should these
architectures be evaluated? In addition, we adopt the B formal method to
support design specifications for agent software architecture. Formal
modeling of a specification of our agent software architecture enables us
to analyze and reason about it ,with mathematical precision and aHows
obtaining the abstract specification of the initial architecture formally.
Besides, the design decisions are stored with the goal of making the
reconfiguration tasks easier by the agent This paper describes work in
progress and presents some interesting ideas connected to architectural
agents.
Key words: Software architecture, Quality attributes, Formal method.



6. Understanding and Propagating Architectural
Changes
Christopher Van der Westhuizen and Andre van der Hoek
Department of Information and Computer Science
University of California, Irvine
Irvine, CA 92697-3425 USA
vanderwe@uci.edu and andre@ics.uci.edu
Abstract: Like source code. architectures change. The use of product line architectures
provides a particularly rich source of changes: new products are introduced,
existing products are enhanced and modified. and old products are retired.
Methods exist that record these kinds of changes by maintaining explicit
representations of the evolution of a product line architecture. Despite the
availability of such representations, it still is difficult to quickly gain an
understanding of the exact changes that define the difference between two
products. Furthermore, it is difficult to automatically propagate such changes
to yet another, third product in the product line. This paper aims to fill this
void and contributes a set of algorithms and an associated representation for
understanding and propagating architectural changes within a product line
architecture. The approach is based on xADL 2.0, an extensible representation
for product line architectures, and adapts well-known differencing and
merging algorithms from the field of configuration management to the domain
of software architecture.
Key words: Architectural change, product line architecture, differencing and merging



7. Practical Rationale for Describing Software
Architecture
Beyond Programming-in-The-Large
Karl Smolanderl , Tero Paivarinta2
1 Lappeenranta University of Technology, Telecom Business Research Center (TBRC),
Department of Information Technology, Laboratory of Information Processing, P. O. Box 20,
FIN-5385J Lappeenranta, Finland,lwri.smolander@lut.fi
2 Agder University College, Dept. of Information Systems, Serviceboks 422, 4604 Kristiansand,
Norway, tero.paivarinta@hia.no
Abstract: The practical rationale for architecture design and description of softwarebased
systems were inquired in three software-producing organizations. In addition
to the traditional programming-in-the-large view that dominates the
mainstream research on software architecture, this grounded-theory based
study suggests that other important purposes for software architecture, especially
such related to decision-making and mutual understanding among the
stakeholders of software development, exist as well in practice. Their emergence
depends on several factors associated with the software development
organization in question: such as the variety of customers and other stakeholders,
the characteristics of software products, and the nature of the business.
Key words: software architecture, qualitative research, architecture description, organizational
aspects of software architecture



8. DOCUMENTING AND ANALYZING A
CONTEXT-SENSITIVE DESIGN SPACE
Hans de Bruin, Hans van Vliet, and Ziv Baida
Vrije Universiteit Amsterdam
Mathematics and Computer Science Department
De Boelelaan 1081a, 1081 HV Amsterdam, The Netherlands
{hansdb,hans,ziv} <Ocs.vu.nl
Abstract In most requirements engineering and software architecture documents, emphasis
is placed on the chosen alternative. The discarded ones, and the arguments
that led to a particular choice, are often not explicitly recorded and documented.
This makes it difficult to retrace decisions and explore alternatives. We have
developed a representation for capturing quality requirements and associated architectural
solution fragments, called the Feature-Solution (FS) graph. We use
the knowledge captured in the FS-graph to iteratively compose an architecture.
This paper shows that when the knowledge in the FS-graph captures contextsensitive
architectural knowledge, such as the concerns of different stakeholders,
this representation can also be used to document and reason about architectural
trade-offs. The result not only documents feasible architectures, but also the
traces of design decisions that led to those architectures, which is a valuable
asset during the further implementation and evolution of the system.



9. INTRODUCING REFLECTION
IN ARCHITECTURE DESCRIPTION LANGUAGES *
Carlos E. Cuesta1, Pablo de la Fuente2 , Manuel Barrio-SoI6rzano3, and M.
Encarnaci6n Beato4
1,2,3 Departamento de Informatica, Universidad de Valladolid, Spain
4 Escuela Universitaria de Informatica, Universidad Pontijicia de Salamanca, Spain
{cecuesta,pfuente,mbarrlo}@lnfor.uva.es, ebeato@upsa.es
Abstract This document describes the structure of 'PiLar, an Architectural Description
Language based on concepts from the field of Reflection, following a proposal
suggested in previous work. First, motivations and ideas behind its design are
outlined. Next, the language is divided in two parts: a declarative Structural
Language, which makes possible to define an architecture's static skeleton; and
an imperative Dynamic Language, which appears as a set of constraining rules
written in a concurrent language. Both languages are intertwined with the reijication
concept, which has a reflective origin. Its meaning and consequences are
commented in detail. After this, the language's formal semantics are informally
described; it is conceived as a system of concurrent processes, communicating by
means of channels. It is argued that this semantics fits perfectly with architectural
concepts. Finally, a solution for the classical problem of the Dining Philosophers
is included as an example, to show how this AOL describes the dynamic evolution
in a system. The paper concludes emphasizing the generality and usefulness of
the language.
Keywords: Software Architecture, Reflection, Dynamic Architecture, Reification, MARMOL,
'PiLar, Meta-Component.




10. Architecture Reconstruction in Practice
Claudio Ri va
Nokia Research Center
P.O. Box 407, F1N-00045, NOKIA GROUP, Finland
Tel: +358504837403, Fax: +358718036308
claudio. riva@nokia.com
Abstract: The description of the software architecture should communicate the essential
decisions that have been taken during the design of the software system.
Architecture reconstruction is a reverse engineering activity that aims at
recovering past decisions that are either unknown (because not documented or
the original developers have left) or new (because originates from the system's
evolution). The reconstruction is performed by examining the available
artefacts (documentation, source code, experts) and by inferring new
architectural information that is not immediately evident.
In this article we describe our architecture reconstruction method and the
environment supporting it. The method emphasises the importance of the
architecturally significant concepts (essential for the architects) and the
domain specific knowledge. They are considered first class entities in the
reconstruction process from the initial stages. We believe that focusing the
reconstruction in this way we can produce quality information for the
architects.
Key words: Reverse engineering, architecture reconstruction, software architecture




11. Introducing the Software Architectonic Viewpoint
Alessandro Maccarit, Galal H. Galall ,2
1: Software Architecture Group, Nokia Research Center, P. O. Box 407, FIN - 00045 NOKlA
GROUP
2: School of lnformatics and Multimedia Technology, University of North London, 166-220
Holloway Road, London N7 8DB.
Abstract: Managing evolution of complex software architecture is a continuous
challenge in industry. Systems such as mobile handsets undergo a continuous
increase in complexity, while the fast market evolution imposes quick
integration of new features. Being able to easily manage software architecture
evolution is the basis for shorter time-to-market and faster product release. The
term ''viewpoint'' has become familiar with the publication of the IEEE
standard 1471-2000 on recommended practices for architectural modelling.
Based on the classical 4+ 1 view model, we have elaborated our own set of
viewpoints in order to support our domain-specific architectural modelling
needs. We hereby justify the introduction of the architectonic viewpoint,
which models the evolutionary aspects of software architecture. The term, as
well as the rationale behind it, is inspired from architecture as in buildings. We
describe the viewpoint and the way it links to the others we use. Additionally,
we briefly elaborate on the other viewpoints that we use for architectural
modelling of mobile telephone software architecture. We provide basis for
discussion and further research into the matter.
Keywords: software architectonics, architectural evolution, the architectonic viewpoint,
architectural viewpoints.



12. A Component-Based Software Architecture for
Industrial Control
Frank Liiders, Ivica Crnkovic, Andreas Sjogren
ABB Automation Technology Products. Miilardalen University
Abstract: When different business units of an international company are responsible for
the development of different parts of a large system, a component-based
software architecture may be a good alternative to more traditional, monolithic
architectures. The new common control system, developed by ABB to replace
several existing control systems. must incorporate support for a large number
of JlO systems, communication interfaces, and communication protocols. An
activity has therefore been started to redesign the system's architecture, so that
110 and communication components can be implemented by different
development centers around the world. This paper reports on experiences from
this effort, describing the system, its current software architecture, the new
component-based architecture, and the lessons learned so far.
Key words: software architecture, component-based software development, industrial
control systems 




13. Analyzing Commercial Component Models
Wayne DePrince Jr. & Christine Hofmeister
Computer Science and Engineering Department
Lehigh University
19 Memorial Drive West, Bethlehem. PA 18015 USA
Abstract: Our goal is this paper was to clarify what commercial component
models provide to support component-based systems. One of the key
motivations was the evident confusion about what a component is, even within
a single component model. In this paper we flfSt make a distinction between
the functionality of a component model and the mechanisms it uses to support
that functionality. We define three kinds of invocation mechanisms for
component model services: explicit, implied, and declarative. We describe the
elements of a component, show how they support the different invocation
mechanisms, and show the role of packaging standards for well-defined
components. The component models we examined fall into three distinct
groups, with lavaBeans at the weak end, CORBA 2.3, COMIDCOM, and
COM+ in the middle, and Em and .NET at the strong end. The strong
component models have configurable execution semantics for operation
invocation, declarative service usage, and, most importantly, a well-defined
component concept. They also have the properties of the middle group of
component models, which use the implied service usage mechanism to support
transparent remote communication, and allow an application to use mUltiple
implementations of a component at a time. COM+ falls between the strong and
middle groups.
Key words: Software architecture, middleware, component model, component, ADL,
CORBA, lavaBeans, IDB, COM, DCOM, COM+, .NET, ActiveX, IDL.




14. A FAMILY OF SOFTWARE ARCmTECTURE
IMPLEMENTATION FRAMEWORKS
Nenad Medvidovic, Nikunj Mehta, and Marija Mikic-Rakic
Computer Science Department
University o/Southern California
Los Angeles. CA 90089-0781. USA
{neno.mehta.marija}@usc.edu
Abstract: Software architectures provide high-level abstractions for representing the structure,
behavior, and key properties of software systems. Various architecture description
languages, styles, tools, and technologies have emerged over the past decade. At the
same time, there has been comparatively little focus on techniques and technologies
for transforming architectural models into running systems. This often results in significant
differences between conceptual and concrete architectures, rendering system
evolution and maintenance difficuh. Furthermore, it calls into question the
ability of developers to consistently transfer the key architectural properties into system
implementations. One solution to this problem is to employ architectural frameworks.
Architectural frameworks provide support for implementing, deploying,
executing, and evolving software architectures. This paper descn'bes the design of
and our experience with a family of architectural frameworks that support implementation
of systems in a specific architectural style-C2. To date, the C2 frameworks
have been used in the development of over 100 applications by several
academic and industrial organizations. The paper discusses the issues we have
encountered in implementing and using the frameworks, as well as the approaches
adopted to resolve these issues.
Keywords: Architectural framework, style, object-orientation, architectural implementation
